> 数组

## 136. 只出现一次的数字

<div>
<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>

<p><strong>说明：</strong></p>

<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>

<p><strong>示例 1:</strong></p>

<pre><strong>输入:</strong> [2,2,1]
<strong>输出:</strong> 1
</pre>

<p><strong>示例&nbsp;2:</strong></p>

<pre><strong>输入:</strong> [4,1,2,1,2]
<strong>输出:</strong> 4</pre>
</div>

#### 方法一：集合

1. 因为数组中元素出现的次数只能是1次或2次
2. 创建一个集合，遍历数组元素
    - 集合中不存在，加入
    - 存在，删除
3. 遍历结束后，集合中剩余元素就是结果

```python
def singleNumber(self, nums: List[int]) -> int:
    s = set()
    for num in nums:
        if num not in s:
            s.add(num)
        else:
            s.remove(num)
    return s.pop()
```

#### 方法二：哈希

1. 遍历数组，将元素出现次数加入哈希表
2. 遍历哈希表，返回value为1的key

```python
def singleNumber(self, nums: List[int]) -> int:
    d = {}
    for num in nums:
        if num not in d:
            d[num] = 1
        else:
            d[num] += 1
    for a in d:
        if d[a] == 1:
            return a
    return -1
```

#### 方法三：集合，数组之和

1. 将数组中元素都加入到集合中
2. 计算数组之和为`s1`,集合中元素之和的2倍为`s2`
3. 返回`s2-s1`

```python
def singleNumber(self, nums: List[int]) -> int:
    s = set(nums)
    s1, s2 = sum(nums), sum(s) * 2
    return s2 - s1
```

#### 方法四：位运算

1. 任何数和0做异或运算，结果仍是原来的数，a ⊕ 0 = a
2. 任何数和其自身做异或运算，结果是0，a ⊕ a = 0
3. 异或运算满足交换律和结合律，a ⊕ b ⊕ a = b ⊕ a ⊕ a =b ⊕ (a ⊕ a) = b ⊕ 0 = b

```python
def singleNumber(self, nums: List[int]) -> int:
    res = 0
    for num in nums:
        res ^= num
    return res
```

## 169. 多数元素

<div>
<p>给定一个大小为 <em>n </em>的数组，找到其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>

<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>


<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>[3,2,3]
<strong>输出：</strong>3</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>[2,2,1,1,1,2,2]
<strong>输出：</strong>2
</pre>

<p><strong>进阶：</strong></p>

<ul>
	<li>尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。</li>
</ul>
</div>

#### 方法一：哈希表

把数组中各元素的数量保存在哈希表中，遍历哈希表

```python
def majorityElement(self, nums: List[int]) -> int:
    d = {}
    for num in nums:
        if num not in d:
            d[num] = 1
        else:
            d[num] += 1
    max_key, max_value = -1, -1
    for k in d:
        if d[k] > max_value:
            max_key = k
            max_value = d[k]
    return max_key
    # 也可直接用collections.Counter，保存数组中各元素的数量，max查找出最大数量的key
    # counts = collections.Counter(nums)
    # return max(counts.keys(), key=counts.get)
```

#### 方法二：排序

排序后中间的那个数即为众数（要求数量大于`⌊n/2⌋`的数）

```python
def majorityElement(self, nums: List[int]) -> int:
    nums.sort()
    return nums[len(nums) // 2]
```

#### 方法三：分治，递归

假设`nums`的众数为`a`，把`nums`分为左右两部分，`a`至少为其中一部分的众数

1. 划分为长度为1的子数组，其中的众数为元素自身
2. 合并区间
    - 左右子数组众数相同
    - 不同，比较两个众数在整个区间出现的次数

```python
def majorityElement(self, nums: List[int]) -> int:
    def majority_element_rec(left, right):
        """查找 left 到 right 之间的众数"""
        if left == right:
            """索引相同，区间长度为1"""
            return nums[left]

        # 划分区间
        mid = left + (right - left) // 2
        left_majority = majority_element_rec(left, mid)
        right_majority = majority_element_rec(mid + 1, right)

        if left_majority == right_majority:
            return left_majority

        # 比较整个区间两个众数的数量
        left_count = sum(1 for i in range(left, right + 1) if nums[i] == left_majority)
        right_count = sum(1 for i in range(left, right + 1) if nums[i] == right_majority)
        print(str(left_count) + ' ' + str(right_count))
        return left_majority if left_count > right_count else right_majority

    return majority_element_rec(0, len(nums) - 1)
```

#### 方法四：摩尔投票法

1. 初始化一个`target`和一个`cnt`
2. 一次遍历，数字相同`cnt+1`，不同`cnt-1`
3. 减为负数后重置`target`,`cnt`

```python
def majorityElement(self, nums: List[int]) -> int:
    if not nums:
        return -1

    target, cnt = nums[0], 0
    for n in nums:
        if target == n:
            cnt += 1
        else:
            cnt -= 1
        if cnt == -1:
            target = n
            cnt = 0
    return target

    # 简化写法
    # count = 0
    # candidate = None
    # 
    # for num in nums:
    #     if count == 0:
    #         candidate = num
    #     count += (1 if num == candidate else -1)
    # return candidate
```

## 15. 三数之和

<div>
<p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c = </em>0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p>

<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [-1,0,1,2,-1,-4]
<strong>输出：</strong>[[-1,-1,2],[-1,0,1]]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = []
<strong>输出：</strong>[]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>nums = [0]
<strong>输出：</strong>[]
</pre>

<p><strong>提示：</strong></p>

<ul>
	<li><code>0 <= nums.length <= 3000</code></li>
	<li><code>-10<sup>5</sup> <= nums[i] <= 10<sup>5</sup></code></li>
</ul>
</div>

#### 方法一：排序+双指针

1. 将数组排序
2. `first`索引逐渐前移，与前一个元素相同则跳过
3. 然后就是双指针的思想
   - 目标值为`-nums[first]`
   - `second`从`first+1`开始右移，`third`从`n-1`开始左移

```python
def threeSum(self, nums: List[int]) -> List[List[int]]:
    n = len(nums)
    nums.sort()
    ans = []

    for first in range(n):
        if first > 0 and nums[first] == nums[first - 1]:
            continue

        third = n - 1
        target = -nums[first]

        # 双指针
        for second in range(first + 1, n):
            if second > first + 1 and nums[second] == nums[second - 1]:
                continue

            while second < third and nums[second] + nums[third] > target:
                # 两数之和大于目标值，third左移
                third -= 1

            if second == third:
                break

            if nums[second] + nums[third] == target:
                ans.append([nums[first], nums[second], nums[third]])

    return ans
```